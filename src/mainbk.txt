#![windows_subsystem = "windows"]
extern crate gdi32;
extern crate kernel32;
extern crate user32;
extern crate winapi;
//extern crate mylib;

mod windows;

use std::ptr::{null, null_mut};
//use std::path::Path;
use windows::menus::{create_menu, EditEntries, FileEntries, Menus};
use windows::utils::{error_msgbox, ToWide, WinStruct};

//use mylib::file_ops::open_file;

use gdi32::GetStockObject;

use user32::{CreateMenu, CreateWindowExW, MessageBoxW, RegisterClassW, ShowWindow, UpdateWindow};
use user32::{DispatchMessageW, GetMessageW, PostQuitMessage, SendMessageW, TranslateMessage};
use user32::{DefWindowProcW, DestroyWindow, FindWindowExW, GetClientRect, MoveWindow, SetWindowPos};
use user32::RegisterHotKey;

use winapi::basetsd::{INT32, UINT32};
use winapi::minwindef::{HINSTANCE, LPARAM, LRESULT, TRUE, WPARAM};
use winapi::windef::{HCURSOR, HFONT, HICON, HWND, RECT};
use winapi::wingdi::DEFAULT_GUI_FONT;
use winapi::winuser::*;

//Window application entry function WinMain
//(body could also be put into fn main() instead of creating a new function)
fn create_winmain() -> usize {
    let class = "mainwindow".to_wide(); //class name of window
    let title = "Project: HotJelly Marmelade".to_wide();

    unsafe {
        let hinstance = 0 as HINSTANCE; //It's the same as calling null_mut() or zeroed()
        //Structure of the window
        let wndclass = WNDCLASSW {
            style: CS_HREDRAW | CS_VREDRAW,
            lpfnWndProc: Some(message_handler), //Calling callback function for processing messages
            cbClsExtra: 0,
            cbWndExtra: 0,
            hInstance: hinstance,
            hIcon: 0 as HICON,
            hCursor: 0 as HCURSOR,
            hbrBackground: null_mut(),
            lpszMenuName: null(),
            lpszClassName: class.as_ptr() as *const u16,
        };

        let hmenubar = CreateMenu();
        create_menu(hmenubar);

        match RegisterClassW(&wndclass) {
            0 => {
                error_msgbox("Failed to register window class!");
                0
            }
            _atom => {
                //Actual main window that is visible
                let hwnd_main = CreateWindowExW(
                    0,
                    class.as_ptr() as *const u16,
                    title.as_ptr() as *const u16,
                    WS_VISIBLE | WS_OVERLAPPEDWINDOW,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    null_mut(),
                    hmenubar,
                    hinstance,
                    null_mut(),
                );

                if hwnd_main.is_null() {
                    error_msgbox("Failed to create window!");
                    PostQuitMessage(0);
                    0
                } else {
                    ShowWindow(hwnd_main, SW_SHOWDEFAULT);
                    UpdateWindow(hwnd_main);
                    //Messaging with OS
                    //Initialize MSG struct with 0 (unsafer alternative: zeroed(), uninitialized())
                    let mut msg: MSG = WinStruct::initialized();

                    RegisterHotKey(hwnd_main, 1, 0x0002, 0x51); //0x51 is Q

                    while GetMessageW(&mut msg as *mut MSG, 0 as HWND, 0, 0) != 0 {
                        TranslateMessage(&msg as *const MSG);
                        DispatchMessageW(&msg as *const MSG);
                    }
                    msg.wParam as usize
                }
            }
        }
    }
}

//Callback function, which processes incoming messages
unsafe extern "system" fn message_handler(
    hwnd_main: HWND, //Handle to main/parent window
    message: UINT32, //System-defined messages (e.g. WM_SIZE)
    wparam: WPARAM, //More message specified information (e.g. User clicked menu item X)
    lparam: LPARAM, //More message specified information
) -> LRESULT {
    //Initialize rect struct with 0
    let mut rc_client: RECT = WinStruct::initialized();

    let hwnd_main_edit = FindWindowExW(
        hwnd_main,
        0 as HWND,
        "EDIT".to_wide().as_ptr() as *const u16,
        null(),
    );

    match message {
        WM_CREATE => {
            let hinstance_child = 0 as HINSTANCE;
            let hwnd_edit = CreateWindowExW(
                0,
                "EDIT".to_wide().as_ptr() as *const u16, //System defined "Edit Control"
                "".to_wide().as_ptr() as *const u16,
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL,
                1,
                1, //Child of main window with vertical scrollbars
                100, //Edit control with multilines enabled
                100,
                hwnd_main,
                null_mut(),
                hinstance_child,
                null_mut(),
            );

            if hwnd_edit.is_null() {
                error_msgbox("Could not create Edit control!");
                0
            } else {
                GetClientRect(hwnd_main, &mut rc_client as *mut RECT);
                SetWindowPos(
                    hwnd_edit,
                    null_mut(),
                    0,
                    0,
                    rc_client.right,
                    rc_client.bottom,
                    SWP_NOZORDER,
                );

                let hfont = GetStockObject(DEFAULT_GUI_FONT) as HFONT; //Gets system font
                SendMessageW(hwnd_edit, WM_SETFONT, hfont as WPARAM, TRUE as LPARAM)
            }
        }
        WM_COMMAND => {
            match Menus::from_wparam(wparam) {
                //Giving menu items functionality
                Some(Menus::File(FileEntries::New)) => 0,
                Some(Menus::File(FileEntries::Open)) => 0,
                Some(Menus::File(FileEntries::Save)) => 0,
                Some(Menus::File(FileEntries::Export)) => {
                    error_msgbox("Not implemented yet.");
                    0
                }
                Some(Menus::File(FileEntries::Print)) => {
                    error_msgbox("Not implemented yet.");
                    0
                }
                Some(Menus::File(FileEntries::Quit)) => {
                    PostQuitMessage(0);
                    0
                }
                Some(Menus::Edit(EditEntries::Redo)) => {
                    SendMessageW(hwnd_main_edit, WM_UNDO, 0, TRUE as LPARAM);
                    0
                }
                Some(Menus::Edit(EditEntries::Repeat)) => {
                    SendMessageW(hwnd_main_edit, WM_UNDO, 0, TRUE as LPARAM);
                    0
                }
                Some(Menus::Edit(EditEntries::Cut)) => {
                    SendMessageW(hwnd_main_edit, WM_CUT, 0, TRUE as LPARAM);
                    0
                }
                Some(Menus::Edit(EditEntries::Copy)) => {
                    SendMessageW(hwnd_main_edit, WM_COPY, 0, TRUE as LPARAM);
                    0
                }
                Some(Menus::Edit(EditEntries::Paste)) => {
                    SendMessageW(hwnd_main_edit, WM_PASTE, 0, TRUE as LPARAM);
                    0
                }
                Some(Menus::Edit(EditEntries::Search)) => {
                    error_msgbox("Not implemented yet.");
                    0
                }
                Some(Menus::Edit(EditEntries::Replace)) => {
                    error_msgbox("Not implemented yet.");
                    0
                }
                None => 1,
            }
        }
        WM_SIZE => {
            if hwnd_main_edit.is_null() {
                error_msgbox("Failed to resize Edit control!");
                0
            } else {
                GetClientRect(hwnd_main, &mut rc_client as *mut RECT);
                MoveWindow(
                    hwnd_main_edit as HWND,
                    0, //Resizes child window with main window
                    0, //when the user resizes window
                    rc_client.right as INT32,
                    rc_client.bottom as INT32,
                    TRUE,
                );
                1
            }
        }
        WM_HOTKEY => {
            match wparam {
                //Processing custom hotkeys defined in create_winmain
                1 => {
                    PostQuitMessage(0);
                    0
                }
                _ => 0,
            }
        }
        WM_CLOSE => {
            if (MessageBoxW(
                hwnd_main,
                "Are you sure you want to quit?".to_wide().as_ptr() as *const u16,
                "Exit Marmelade".to_wide().as_ptr() as *const u16,
                MB_YESNO,
            )) == 6
            //Yes Button was pressed (6 = IDYES)
            {
                DestroyWindow(hwnd_main);
                1 //(1 = IDOK)
            } else {
                2 //(2 = IDCANCEL)
            }
        }
        WM_DESTROY => {
            PostQuitMessage(0);
            0
        }
        _ => DefWindowProcW(hwnd_main, message, wparam, lparam),
    }
}

fn main() {
    create_winmain();
}
